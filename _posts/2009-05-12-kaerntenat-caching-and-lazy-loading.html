---
layout: post
title: "kaernten.at &ndash; Caching and Lazy loading"
guid: http://www.tigraine.at/2009/05/12/kaerntenat-caching-and-lazy-loading/
postid: 518
categories:
- net
- programmierung
- job
---
<p>In my last post on the <a href="http://www.tigraine.at/2009/05/12/the-technology-behind-kaerntenat/">technology behind www.kaernten.at</a>, I concluded with the fairly bold statement that all objects are kept in memory to ease querying.</p>  <p>That’s not really true, but also not really false.    <br />When the article list is loaded initially, only a slim index of all articles is retrieved from the database. All information relevant to querying and sorting (id, tags, publication date, visibility) gets fetched at once. I used Castle DynamicProxy2 to create proxy objects that pose a the real thing to lazy load the article data on access. So although there may be 10.000 articles currently in memory, only those that have really been viewed by a user have been fully loaded, while all query criteria are present in memory. </p>  <p>But lazy loading wouldn’t work if the list of proxy objects wouldn’t get cached somewhere, and that’s what I wanted to go over in this post. All articles retrieved (in their proxied form) come from the generic IRepository&lt;T&gt; interface that only has one method: GetAll(). I wanted to avoid having the caching be tied into the Repository at all costs since it would make my life hell when testing the repository itself. So I decided that the best course of action would be to create a decorator that took care of the caching, separating caching from the Repository implementation (and it’s also really easy if there is only one method to implement):</p>  <p><img title="image" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="378" alt="image" src="http://www.tigraine.at/wp-content/uploads/2009/05/image1.png" width="508" border="0" /> </p>  <p>Switching caching on or off is now as simple as removing/adding one line to the Windsor configuration. And the caching code is shared among all Repository implementations, for any type of IArticleRepository&lt;T&gt;.    <br />If it needs to get cleared I can simply ask the Windsor container to retrieve all ICache implementing classes (they are singletons) and call ICache.Clear() on them.</p>  <p>Now, the most interesting thing here is that the <em>cache is asynchronous</em>. If it gets cleared, a background worker process gets spawned on the PopulateCache() method, generating the updated data from the system, while subsequent requests to the Repository (while it’s being populated) still return the outdated list of data. Once the background worker is done populating, it simply swaps out the references and the old data gets collected by the garbage collector.     <br />This result in some pretty sweet response times, since except for the very first startup of the system, every request is served directly from memory, without any data fetching at all.</p>  <p>This part was also crucial to the whole thing since fetching the data is a rather long running and cpu heavy task, taking up to 60 seconds while testing it against 10.000 articles (with a debugger attached on my laptop).    <br />Initially I tried to speed the querying and object building up to allow for a synchronous cache refill, but although I did some optimizations (like <a href="http://www.tigraine.at/2009/03/06/do-you-really-know-what-linq-does/">not using some LinQ methods</a>) the attempt to reduce the execution time to something acceptable was futile. </p>  <p>Right now the cache is implemented by just a simple List&lt;T&gt; that stores everything the repository returned, but if need arises it can easily be changed to use memcached or some other more sophisticated caching method.</p>