---
layout: post
title: "Using ILMerge to hide your dependencies"
guid: http://www.tigraine.at/2009/10/01/using-ilmerge-to-hide-your-dependencies/
postid: 773
categories:
- net
- programmierung
- tools
---
<p>When developing a library that should be used by 3rd parties one major concern is dependency versioning. Meaning, if your code uses a common library like Castle.Windsor, things will get ugly if your users also use Castle.Windsor in another version. </p>  <p>Especially with very popular infrastructure libraries like Castle you can’t expect all your users not to use it, after all you’re probably using it for the same reason they do: Best of breed solution to a common problem.    <br />To avoid trouble, many library authors decide not to take external dependencies so they won’t see versioning issues, while having to re-implement some infrastructure themselves.</p>  <p>Coming up with something simple usually isn’t that hard. If you just need a very limited feature set you can <a href="http://www.tigraine.at/2009/05/21/my-very-own-inversion-of-control-container/">build your own Inversion of Control container</a> quite easily without relying on external libraries. Yet, if you do you still have to spend time building, maintaining and extending the thing over time. </p>  <p>The other option is to use the fabulous tool <a href="http://research.microsoft.com/en-us/people/mbarnett/ilmerge.aspx">ILMerge</a> by Microsoft that allows you to munch multiple assemblies into one DLL. This is also handy if your product consists of many assemblies that you want to bundle, but in this case there is one cool thing ILMerge does: /internalize</p>  <p>ILMerge usually is called from the command line and works like this:</p>  <blockquote>   <p>ILMerge.exe &lt;main-assembly.dll&gt; [&lt;library1.dll&gt; &lt;library2.dll&gt;] /out:&lt;output-file.dll&gt; /t:library</p> </blockquote>  <p>Now if you add the magic parameter <u>/internalize</u> ILmerge will hide all type names inside &lt;library1.dll&gt; and &lt;library2.dll&gt; from assemblies that reference the output assembly.</p>  <p>So in <a href="http://www.tigraine.at/2009/09/29/introducing-elms-connector-v-1-beta/">ElmsConnector’s</a> case where Windsor is used internally the ILMerge call looks like this:</p>  <p><a href="http://www.tigraine.at/wp-content/uploads/2009/10/image.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://www.tigraine.at/wp-content/uploads/2009/10/image_thumb.png" width="441" height="149" /></a> </p>  <p>ElmsConnector-partial.dll is the original output dll from my msbuild process while ILMerge will merge all of these Castle assemblies into the output ElmsConnector.dll.    <br />Now the real magic here is that if I open the resulting assembly in Reflector it still lists all Castle assemblies:</p>  <p><a href="http://www.tigraine.at/wp-content/uploads/2009/10/image1.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://www.tigraine.at/wp-content/uploads/2009/10/image_thumb1.png" width="341" height="219" /></a> </p>  <p>But inside Visual Studio none of the Castle.* namespaces exists because they are hidden. </p>  <p>This technique allows us to use our favorite tools in libraries without having to think too hard about versioning.</p>  <p>Now, obviously there are also some things to consider here:    <br />If you want to expose any class that is inside one of the internalized assemblies, you have to tell ILMerge so through the exclude file (<a href="http://github.com/ayende/rhino-mocks/blob/master/ilmerge.exclude">an example of this</a> can be seen with Rhino.Mocks). Once you exclude one type and your users try to use that type they will see a “ambiguous type” compile-time error. That’s why Rhino.Mocks also comes in a unmerged flavor </p>  <p>Another thing to remember is (especially with web-apps) that your users can’t see any internalized assemblies, so any configuration you put into your web.config for them won’t work. Best example may be the PerWebRequest lifesyle for Windsor: It relies on a httpModule to be registered through the web.config, you can’t make that happen with the externalized assembly (and it leads to versioning problems once you exclude it).</p>